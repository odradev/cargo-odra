//! Module containing code that parses CLI input.

use std::env;

use clap::{Parser, Subcommand};

use crate::{
    actions::{clean::clean_action, init::InitAction, update::update_action},
    consts,
    errors::Error,
    project::Project,
};

#[derive(Parser)]
#[clap(name = "cargo")]
#[clap(bin_name = "cargo")]
/// Main command `cargo`.
pub enum Cargo {
    Odra(Odra),
}

#[derive(clap::Args)]
#[clap(author, version, about, long_about = None)]
/// `cargo odra`
pub struct Odra {
    #[clap(subcommand)]
    subcommand: OdraSubcommand,

    #[clap(value_parser, long, short, global = true)]
    /// Be verbose.
    pub verbose: bool,

    #[clap(value_parser, long, short, global = true)]
    /// Be quiet, show only errors.
    pub quiet: bool,
}

#[derive(Subcommand)]
/// Subcommands of `cargo odra`.
pub enum OdraSubcommand {
    /// Creates a new Odra project.
    New(InitCommand),
    /// Initializes a new Odra project in an existing, empty directory.
    Init(InitCommand),
    /// Builds the project, including backend and producing wasm files.
    Build(BuildCommand),
    /// Runs test. Without the backend parameter, the tests will be run against Mock VM.
    Test(TestCommand),
    /// Generates boilerplate code for contracts.
    Generate(GenerateCommand),
    /// Cleans all temporary data generated by cargo odra.
    Clean(CleanCommand),
    /// Updates project alongside builders.
    Update(UpdateCommand),
}

#[derive(clap::Args)]
/// `cargo odra init`
pub struct InitCommand {
    /// Name which will be used as a name for the crate.
    #[clap(value_parser, long, short)]
    pub name: String,
    /// URI of the repository containing the template.
    #[clap(value_parser, long, short, default_value = consts::ODRA_TEMPLATE_GH_REPO)]
    pub repo_uri: String,
    /// Odra source to use. By default, it uses latest release of Odra.
    /// It can be a version, a branch, commit hash or a location on the filesystem.
    #[clap(value_parser, long, short)]
    pub source: Option<String>,
    /// Template to use. Default is "full", which contains a sample contract and a test.
    /// To see all available templates, run `cargo odra new --list`.
    #[clap(value_parser, long, short, default_value = consts::ODRA_TEMPLATE_DEFAULT_TEMPLATE)]
    pub template: String,
}

#[derive(clap::Args)]
/// `cargo odra build`
pub struct BuildCommand {
    /// Name of the backend that will be used for the build process (e.g. casper).
    #[clap(value_parser, long, short, value_parser = [consts::ODRA_CASPER_BACKEND])]
    pub backend: String,

    /// Contracts names separated by a space that matches the names in Odra.toml.
    #[clap(value_parser, long, short)]
    pub contracts_names: Option<String>,
}

#[derive(clap::Args, Debug)]
/// `cargo odra test`
pub struct TestCommand {
    /// If set, runs tests against a backend VM with the given name (e.g. casper).
    #[clap(value_parser, long, short, value_parser = [consts::ODRA_CASPER_BACKEND])]
    pub backend: Option<String>,
    /// A list of arguments is passed to the cargo test command.
    #[clap(raw = true)]
    pub args: Vec<String>,
    /// Skip building wasm files.
    #[clap(value_parser, long, short, default_value = "false")]
    pub skip_build: bool,
}

#[derive(clap::Args, Debug)]
/// `cargo odra generate`
pub struct GenerateCommand {
    /// Name of the contract to be created.
    #[clap(value_parser, long, short)]
    pub contract_name: String,
    /// Name of the module in which the contract will be created.
    #[clap(value_parser, long, short)]
    pub module: Option<String>,
}

#[derive(clap::Args, Debug)]
/// `cargo odra clean`
pub struct CleanCommand {}

#[derive(clap::Args, Debug)]
/// `cargo odra update`
pub struct UpdateCommand {
    /// If set, runs cargo update for the given builder instead of everyone.
    #[clap(value_parser, long, short, value_parser = [consts::ODRA_CASPER_BACKEND])]
    pub backend: Option<String>,
}

/// Cargo odra main parser function.
pub fn make_action() {
    let Cargo::Odra(args) = Cargo::parse();
    let current_dir = env::current_dir()
        .unwrap_or_else(|_| Error::CouldNotDetermineCurrentDirectory.print_and_die());
    match args.subcommand {
        OdraSubcommand::Build(build) => {
            let contracts_names = parse_contracts_names(build.contracts_names);
            Project::detect(current_dir).build(build.backend, contracts_names);
        }
        OdraSubcommand::Test(test) => {
            Project::detect(current_dir).test(test);
        }
        OdraSubcommand::Generate(generate) => {
            Project::detect(current_dir).generate(generate);
        }
        OdraSubcommand::New(init) => {
            Project::init(InitAction {
                project_name: init.name,
                generate: true,
                init: false,
                repo_uri: init.repo_uri,
                source: init.source,
                workspace: false,
                template: init.template,
                current_dir,
            });
        }
        OdraSubcommand::Init(init) => {
            Project::init(InitAction {
                project_name: init.name,
                generate: true,
                init: true,
                repo_uri: init.repo_uri,
                source: init.source,
                workspace: false,
                template: init.template,
                current_dir,
            });
        }
        OdraSubcommand::Clean(_) => {
            let project = Project::detect(current_dir);
            clean_action(project.project_root());
        }
        OdraSubcommand::Update(update) => {
            let project = Project::detect(current_dir);
            update_action(update, project.project_root());
        }
    }
}

fn parse_contracts_names(input: Option<String>) -> Vec<String> {
    match input {
        Some(string) => {
            remove_extra_spaces(&string)
                .map(|string| string.split(' ').map(ToString::to_string).collect::<Vec<_>>())
                .unwrap_or_else(|_| Error::FailedToParseArgument("contracts_names".to_string()).print_and_die())
        },
        None => vec![],
    }
}

fn remove_extra_spaces(input: &str) -> Result<String, &'static str> {
    // Ensure there are no other separators
    if input.chars().any(|c| c.is_whitespace() && c != ' ') {
        return Err("Input contains non-space whitespace characters");
    }

    let trimmed = input.split_whitespace().collect::<Vec<&str>>().join(" ");
    Ok(trimmed.to_owned())
}
